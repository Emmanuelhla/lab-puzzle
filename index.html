<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Awesome Puzzle Adventure!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-confetti@latest/dist/js-confetti.browser.js"></script>
    <style>
    body {
        font-family: 'Inter', sans-serif;
        background-color: #f3f4f6;
    }
    .puzzle-piece {
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        cursor: grab;
        background-size: 200% 200%;
        z-index: 20; /* Ensure puzzle pieces are always on top */
        position: relative; /* Needed for z-index to work */
    }
    .puzzle-piece:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .puzzle-piece.dragging {
        opacity: 0.7;
        transform: scale(1.1);
        cursor: grabbing;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    /* New style for dropped pieces */
    .puzzle-piece.dropped {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    .modal {
        display: none;
    }
    .modal-overlay {
        background-color: rgba(0, 0, 0, 0.5);
    }
</style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 bg-sky-200">

    <div id="how-to-play-modal" class="modal fixed inset-0 z-50 flex items-center justify-center modal-overlay">
        <div class="bg-white p-8 rounded-2xl shadow-xl max-w-xl w-full text-center">
            <h2 class="text-3xl font-bold mb-4 text-purple-600">Welcome to the Puzzle Adventure! 🚀</h2>
            <p class="text-lg text-gray-700 mb-6">
                Drag the puzzle pieces from the right panel and drop them into the empty slots on the left board. Complete all the puzzles to win!
            </p>
            <button id="start-game-button" class="px-8 py-3 bg-purple-600 text-white font-bold rounded-full shadow-lg hover:bg-purple-700 transition-colors duration-300">
                Start Game!
            </button>
        </div>
    </div>

    <div id="info-quiz-modal" class="modal fixed inset-0 z-50 flex items-center justify-center modal-overlay">
        <div class="bg-white p-8 rounded-2xl shadow-xl max-w-xl w-full text-center flex flex-col items-center">
            <h2 id="quiz-title" class="text-3xl font-bold mb-4 text-purple-600"></h2>
            <p id="tool-info" class="text-lg text-gray-700 mb-6"></p>
            <p id="quiz-question" class="text-2xl font-semibold text-gray-800 mb-4"></p>
            <div id="quiz-options" class="flex flex-col gap-3 w-full"></div>
            <p id="quiz-feedback" class="text-lg font-bold mt-4"></p>
        </div>
    </div>

    <main class="w-full max-w-4xl p-6 bg-white shadow-2xl rounded-2xl flex flex-col items-center gap-6 transform transition-all duration-300 scale-95 hover:scale-100">

        <h1 id="main-title" class="text-4xl font-extrabold text-gray-800 tracking-tight text-center">
            Awesome Puzzle Adventure! ✨
        </h1>
        <p id="game-progress" class="text-lg text-gray-600 text-center">Puzzle 1 of 6</p>

        <div id="game-container" class="flex flex-col lg:flex-row items-center gap-8 w-full p-4">
            <div id="puzzle-board" class="grid w-full lg:w-1/2 aspect-square p-2 bg-gray-200 border-4 border-dashed border-gray-400 rounded-lg grid-cols-2 gap-1 relative">
            </div>

            <div id="puzzle-pieces-container" class="grid w-full lg:w-1/2 aspect-square p-2 bg-gray-300 rounded-lg grid-cols-2 gap-1">
            </div>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 w-full">
            <button id="reset-button" class="px-6 py-2 bg-emerald-500 text-white font-bold rounded-full shadow-lg hover:bg-emerald-600 transition-colors duration-300 focus:outline-none focus:ring-4 focus:ring-emerald-400 focus:ring-opacity-50">
                Reset Puzzle
            </button>
        </div>

        <div id="status-message" class="text-xl font-semibold text-center text-gray-800 transition-opacity duration-300 mt-4">
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const puzzleBoard = document.getElementById('puzzle-board');
            const piecesContainer = document.getElementById('puzzle-pieces-container');
            const statusMessage = document.getElementById('status-message');
            const resetButton = document.getElementById('reset-button');
            const gameProgress = document.getElementById('game-progress');
            const howToPlayModal = document.getElementById('how-to-play-modal');
            const startGameButton = document.getElementById('start-game-button');
            const mainTitle = document.getElementById('main-title');
            const infoQuizModal = document.getElementById('info-quiz-modal');
            const quizTitle = document.getElementById('quiz-title');
            const toolInfo = document.getElementById('tool-info');
            const quizQuestion = document.getElementById('quiz-question');
            const quizOptions = document.getElementById('quiz-options');
            const quizFeedback = document.getElementById('quiz-feedback');

            const jsConfetti = new JSConfetti();

            // Define the puzzles with image URLs and new educational content
            const puzzles = [
                {
                    name: "Graduated Dropper", img: "assets/graduated_dropper.jpg",
                    info: "A graduated dropper, or Pasteur pipette, is a glass or plastic tube with a narrow opening at one end and a rubber bulb at the other. The markings on the tube indicate the volume of liquid, allowing for the transfer of specific, small amounts.",
                    quiz: {
                        question: "What is the primary function of a graduated dropper?",
                        options: ["Measuring a large volume of liquid", "Heating chemicals", "Transferring a precise, small volume of liquid", "Mixing two solutions"],
                        correctAnswer: "Transferring a precise, small volume of liquid"
                    }
                },
                {
                    name: "Clear Glass", img: "assets/clear_glass.jpg",
                    info: "A beaker is a simple container used for stirring, mixing, and heating liquids in a laboratory. The lipped spout makes it easy to pour, and the markings on the side provide an approximate measure of volume.",
                    quiz: {
                        question: "What feature of a beaker helps with pouring liquids?",
                        options: ["Its flat bottom", "The lipped spout", "The narrow opening", "Its small size"],
                        correctAnswer: "The lipped spout"
                    }
                },
                {
                    name: "Erlenmeyer Flask Set", img: "assets/erlenmeyer_flask_set.jpg",
                    info: "Erlenmeyer flasks are conical flasks with a flat bottom and a cylindrical neck. Their shape makes them ideal for swirling liquids without the risk of spillage. They are often used for mixing solutions and titrations.",
                    quiz: {
                        question: "Why is an Erlenmeyer flask a good choice for swirling liquids?",
                        options: ["It is transparent", "Its wide bottom prevents it from tipping over", "Its conical shape and narrow neck reduce spills", "It is made of heat-resistant glass"],
                        correctAnswer: "Its conical shape and narrow neck reduce spills"
                    }
                },
                {
                    name: "Pyrex Flask", img: "assets/pyrex_flask.jpg",
                    info: "Pyrex is a brand of borosilicate glass, which is known for its ability to withstand extreme temperature changes without shattering. This makes Pyrex flasks highly valuable in lab settings where heating chemicals is common.",
                    quiz: {
                        question: "What is the main benefit of using a Pyrex flask?",
                        options: ["It is inexpensive to produce", "It is resistant to thermal shock", "It is very light", "It is easy to clean"],
                        correctAnswer: "It is resistant to thermal shock"
                    }
                },
                {
                    name: "Transferpette", img: "assets/transferpette.jpg",
                    info: "A Transferpette, or micropipette, is used to transfer very precise, small volumes of liquid, often in the microliter range. It uses disposable tips to prevent cross-contamination between samples.",
                    quiz: {
                        question: "What is a key feature of a micropipette?",
                        options: ["Its long neck", "Its ability to heat liquids", "Its use of disposable tips for accuracy", "Its capacity for large volumes"],
                        correctAnswer: "Its use of disposable tips for accuracy"
                    }
                },
                {
                    name: "Volumetric Flask", img: "assets/volumetric_flask.jpg",
                    info: "A volumetric flask is a type of lab flask with a flat bottom and a long, narrow neck with a single marking. It is used to prepare solutions to a precise, known volume, which is essential for accurate chemical analysis.",
                    quiz: {
                        question: "What is the key purpose of a volumetric flask?",
                        options: ["Storing corrosive chemicals", "Measuring approximate volumes", "Preparing solutions to a precise volume", "Mixing different types of liquids"],
                        correctAnswer: "Preparing solutions to a precise volume"
                    }
                }
            ];

            const rows = 2;
            const cols = 2;
            const totalPieces = rows * cols;

            let currentPuzzleIndex = 0;
            let draggingPiece = null;

            // --- Game Initialization and Reset ---
            function initializeGame(puzzleIndex) {
                puzzleBoard.innerHTML = '';
                piecesContainer.innerHTML = '';
                statusMessage.textContent = ``;

                const currentPuzzle = puzzles[puzzleIndex];

                mainTitle.innerHTML = `${currentPuzzle.name} Puzzle 🧩`;
                gameProgress.textContent = `Puzzle ${puzzleIndex + 1} of ${puzzles.length}`;

                const pieces = [];
                for (let i = 0; i < totalPieces; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const piece = document.createElement('div');

                    piece.classList.add('puzzle-piece', 'rounded-lg', 'shadow-md', 'border-2', 'border-purple-300');
                    piece.style.backgroundImage = `url(${currentPuzzle.img})`;
                    piece.style.backgroundPosition = `-${col * 100}% -${row * 100}%`;
                    piece.setAttribute('draggable', 'true');
                    piece.dataset.id = i;
                    pieces.push(piece);
                }

                for (let i = 0; i < totalPieces; i++) {
                    const dropZone = document.createElement('div');
                    // Add position relative to the drop zone to act as a positioning context
                    dropZone.classList.add('w-full', 'h-full', 'drop-zone', 'relative');
                    dropZone.dataset.id = i;
                    puzzleBoard.appendChild(dropZone);
                }

                const shuffledPieces = [...pieces].sort(() => Math.random() - 0.5);
                shuffledPieces.forEach(piece => {
                    piecesContainer.appendChild(piece);
                });

                resetButton.textContent = "Reset Puzzle";
            }

            // --- Drag and Drop Event Listeners ---
            piecesContainer.addEventListener('dragstart', (e) => {
                const target = e.target.closest('.puzzle-piece');
                if (target) {
                    draggingPiece = target;
                    target.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', target.dataset.id);
                }
            });

            piecesContainer.addEventListener('dragend', (e) => {
                const target = e.target.closest('.puzzle-piece');
                if (target) {
                    target.classList.remove('dragging');
                    draggingPiece = null;
                }
            });

            puzzleBoard.addEventListener('dragover', (e) => {
                e.preventDefault();
                const dropZone = e.target.closest('.drop-zone');
                if (dropZone && !dropZone.hasChildNodes()) {
                    dropZone.classList.add('bg-purple-200');
                }
            });

            puzzleBoard.addEventListener('dragleave', (e) => {
                const dropZone = e.target.closest('.drop-zone');
                if (dropZone) {
                    dropZone.classList.remove('bg-purple-200');
                }
            });

            puzzleBoard.addEventListener('drop', (e) => {
                e.preventDefault();
                const dropZone = e.target.closest('.drop-zone');
                const pieceId = e.dataTransfer.getData('text/plain');
                const piece = document.querySelector(`.puzzle-piece[data-id="${pieceId}"]`);

                if (dropZone && !dropZone.hasChildNodes() && piece) {
                    dropZone.classList.remove('bg-purple-200');
                    dropZone.appendChild(piece);
                    // Add the 'dropped' class to handle positioning
                    piece.classList.add('dropped');
                    checkWin();
                }
            });

            // --- Win Condition Check ---
            function checkWin() {
                const dropZones = Array.from(puzzleBoard.children).filter(el => el.classList.contains('drop-zone'));
                const solved = dropZones.every(zone => {
                    const piece = zone.firstElementChild;
                    return piece && parseInt(piece.dataset.id) === parseInt(zone.dataset.id);
                });

                const allFilled = dropZones.every(zone => zone.hasChildNodes());

                if (solved) {
                    // Confetti and then show the info/quiz modal
                    jsConfetti.addConfetti();
                    setTimeout(() => {
                        showInfoAndQuiz();
                    }, 1500);
                } else if (allFilled) {
                    statusMessage.textContent = "❌ That's not quite right. Reset and try again!";
                    statusMessage.classList.add('text-red-600', 'animate-pulse');
                    setTimeout(() => {
                        statusMessage.classList.remove('text-red-600', 'animate-pulse');
                    }, 3000);
                }
            }
            
            // --- Info & Quiz Functions ---
            function showInfoAndQuiz() {
                const currentPuzzle = puzzles[currentPuzzleIndex];
                quizTitle.textContent = `${currentPuzzle.name}`;
                toolInfo.textContent = currentPuzzle.info;
                quizQuestion.textContent = currentPuzzle.quiz.question;
                
                quizOptions.innerHTML = '';
                currentPuzzle.quiz.options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.classList.add('px-4', 'py-2', 'bg-gray-200', 'rounded-lg', 'text-gray-800', 'font-bold', 'hover:bg-gray-300', 'transition-colors', 'duration-200');
                    button.addEventListener('click', () => handleQuizAnswer(option, currentPuzzle.quiz.correctAnswer));
                    quizOptions.appendChild(button);
                });
                
                quizFeedback.textContent = '';
                infoQuizModal.style.display = 'flex';
            }
            
            function handleQuizAnswer(selectedOption, correctAnswer) {
                if (selectedOption === correctAnswer) {
                    quizFeedback.textContent = "✅ Correct! Great job!";
                    quizFeedback.classList.remove('text-red-600');
                    quizFeedback.classList.add('text-green-600');
                    setTimeout(() => {
                        infoQuizModal.style.display = 'none';
                        if (currentPuzzleIndex < puzzles.length - 1) {
                            currentPuzzleIndex++;
                            initializeGame(currentPuzzleIndex);
                        } else {
                            endGame();
                        }
                    }, 1500);
                } else {
                    quizFeedback.textContent = "❌ Incorrect. Try again!";
                    quizFeedback.classList.remove('text-green-600');
                    quizFeedback.classList.add('text-red-600');
                }
            }

            function endGame() {
                jsConfetti.addConfetti({
                    emojis: ['🎉', '🚀', '✨', '🌟'],
                    confettiRadius: 6,
                    confettiNumber: 500
                });
                // Clear the puzzle board
                puzzleBoard.innerHTML = '';

                // Create a new image element for the celebration emoji
                const celebrationEmoji = document.createElement('img');
                celebrationEmoji.src = 'assets/party-face-emoji-on-transparent-free-png.webp';
                celebrationEmoji.alt = 'Celebration Emoji';
                celebrationEmoji.classList.add('absolute', 'inset-0', 'w-full', 'h-full', 'object-contain', 'p-4', 'animate-pulse');

                // Append the emoji to the board
                puzzleBoard.appendChild(celebrationEmoji);

                piecesContainer.innerHTML = '';
                mainTitle.innerHTML = `
                    Congratulations! 🎉
                `;
                gameProgress.textContent = "You've successfully completed all the puzzles! 🎉";
                statusMessage.textContent = "You are an amazing puzzle master!";
                statusMessage.classList.add('text-purple-600', 'animate-pulse');
                resetButton.textContent = "Play Again?";
            }

            // --- Button Event Listeners ---
            resetButton.addEventListener('click', () => {
                if (resetButton.textContent === "Play Again?") {
                    currentPuzzleIndex = 0;
                    initializeGame(currentPuzzleIndex);
                } else {
                    initializeGame(currentPuzzleIndex);
                }
                statusMessage.classList.remove('text-purple-600', 'text-emerald-600', 'animate-pulse', 'text-red-600');
                statusMessage.textContent = "Puzzle reset.";
            });

            startGameButton.addEventListener('click', () => {
                howToPlayModal.style.display = 'none';
                initializeGame(currentPuzzleIndex);
            });

            // Initial call to show the "how to play" modal at startup
            howToPlayModal.style.display = 'flex';
        });
    </script>
</body>
</html>
